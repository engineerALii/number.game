<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ÿßŸÑÿ≥ŸÑŸÖ ŸàÿßŸÑÿ´ÿπÿ®ÿßŸÜ: ÿßŸÑŸÜÿ≥ÿÆÿ© ÿßŸÑŸÖÿ∂ŸÖŸàŸÜÿ©</title>
    <style>
        :root {
            --bg-gradient: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            --board-bg: #fdfbf7;
            --cell-1: #ffffff;
            --cell-2: #e3f2fd;
            --grid-line: #cfd8dc;
            --text-color: #37474f;
            --accent: #ff9800;
        }

        body.night-mode {
            --bg-gradient: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
            --board-bg: #263238;
            --cell-1: #37474f;
            --cell-2: #455a64;
            --grid-line: #546e7a;
            --text-color: #eceff1;
        }

        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; font-family: Tahoma, sans-serif; }

        body {
            margin: 0; padding: 0; height: 100vh; overflow: hidden;
            background: var(--bg-gradient); color: var(--text-color);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: background 0.5s;
        }

        /* Loading */
        #loading-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #222; z-index: 9999;
            display: flex; flex-direction: column; justify-content: center; align-items: center; color: white;
        }

        /* Screens */
        .screen { width: 100%; height: 100%; display: none; flex-direction: column; align-items: center; justify-content: center; }
        .screen.active { display: flex; }

        /* Game Layout */
        #game-area {
            position: relative;
            width: 95vmin; height: 95vmin;
            max-width: 600px; max-height: 600px;
            background: var(--board-bg);
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            display: flex; flex-wrap: wrap;
            border: 8px solid #5d4037;
        }

        /* The Grid Cells */
        .cell {
            width: 10%; height: 10%;
            border: 1px solid var(--grid-line);
            display: flex; justify-content: flex-start; align-items: flex-start;
            padding: 2px; font-size: 0.7rem; font-weight: bold;
            position: absolute; /* Absolute positioning for perfect math */
            transition: background 0.3s;
        }
        .cell:nth-child(odd) { background-color: var(--cell-1); }
        .cell:nth-child(even) { background-color: var(--cell-2); }

        /* SVG Overlay for Snakes/Ladders */
        #connections-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
        }

        /* Players */
        .player-token {
            position: absolute; width: 6%; height: 6%;
            z-index: 20; border-radius: 50%; border: 2px solid white;
            box-shadow: 0 3px 6px rgba(0,0,0,0.4);
            /* Important: Transition updated for step-by-step smoothness */
            transition: top 0.3s linear, left 0.3s linear, transform 0.5s;
            background-size: cover; background-position: center;
            transform: translate(-50%, -50%); 
        }
        .player-token.moving { transform: translate(-50%, -50%) scale(1.3); z-index: 30; }

        /* UI Controls (Bottom Bar) */
        #ui-bar {
            width: 95vmin; max-width: 600px;
            height: 80px; margin-top: 10px;
            background: rgba(0,0,0,0.3); border-radius: 15px;
            display: flex; align-items: center; justify-content: space-between;
            padding: 0 20px; color: white;
        }

        #dice-box {
            width: 50px; height: 50px; perspective: 400px; cursor: pointer;
            transition: transform 0.1s;
        }
        
        /* ÿ™ÿ£ÿ´Ÿäÿ± ÿßŸÑŸÇŸÅÿ≤ ŸÑŸÑŸÜÿ±ÿØ */
        @keyframes dice-jump {
            0% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-60px) scale(1.2) rotateZ(10deg); }
            100% { transform: translateY(0) scale(1); }
        }
        #dice-box.jumping {
            animation: dice-jump 0.8s ease-in-out;
        }

        #dice {
            width: 100%; height: 100%; position: relative;
            transform-style: preserve-3d; 
            /* ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ŸÖŸÜÿ≠ŸÜŸâ ÿ≠ÿ±ŸÉÿ© ŸäŸÖÿßÿ´ŸÑ ÿßŸÑŸÅŸäÿ≤Ÿäÿßÿ° (ÿßÿ±ÿ™ÿØÿßÿØ ÿÆŸÅŸäŸÅ ŸÅŸä ÿßŸÑŸÜŸáÿßŸäÿ©) */
            transition: transform 1s cubic-bezier(0.19, 1, 0.22, 1);
        }
        .face {
            position: absolute; width: 50px; height: 50px; background: white;
            border-radius: 8px; display: flex; justify-content: center; align-items: center;
            font-size: 1.5rem; color: #333; box-shadow: inset 0 0 5px #ccc;
        }
        .front { transform: translateZ(25px); }
        .back { transform: rotateY(180deg) translateZ(25px); }
        .right { transform: rotateY(90deg) translateZ(25px); }
        .left { transform: rotateY(-90deg) translateZ(25px); }
        .top { transform: rotateX(90deg) translateZ(25px); }
        .bottom { transform: rotateX(-90deg) translateZ(25px); }

        #roll-btn {
            background: var(--accent); border: none; padding: 10px 25px;
            border-radius: 20px; font-weight: bold; color: white;
            box-shadow: 0 4px 0 #e65100; cursor: pointer;
        }
        #roll-btn:active { transform: translateY(4px); box-shadow: none; }
        #roll-btn:disabled { background: #777; box-shadow: none; opacity: 0.7; }

        #status-txt { font-size: 0.9rem; text-align: right; flex: 1; margin-right: 15px; }

        /* Menu & Winner Box */
        .menu-box {
            background: rgba(255,255,255,0.95); padding: 30px; border-radius: 20px;
            text-align: center; color: #333; width: 90%; max-width: 350px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }
        .menu-box input { width: 100%; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-radius: 5px; }
        .menu-box button { width: 100%; padding: 10px; background: var(--accent); color: white; border: none; border-radius: 5px; margin-top: 5px; cursor: pointer; }

        /* Night Toggle */
        #night-btn {
            position: absolute; top: 20px; right: 20px;
            background: rgba(0,0,0,0.2); color: white; border: 1px solid rgba(255,255,255,0.3);
            width: 40px; height: 40px; border-radius: 50%; font-size: 1.2rem; cursor: pointer;
            z-index: 100;
        }

        /* Room Badge (New Feature) */
        #room-badge {
            position: fixed; top: 20px; left: 20px;
            background: rgba(0, 0, 0, 0.4); backdrop-filter: blur(5px);
            color: #fff; padding: 8px 15px; border-radius: 20px;
            font-family: monospace; font-size: 1rem;
            z-index: 100; display: none;
            border: 1px solid rgba(255,255,255,0.2);
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }
        #room-badge.visible { display: block; }

        /* Chat Styles - Fixed Visibility */
        #chat-modal {
            position: fixed; bottom: 100px; left: 20px; width: 300px; height: 350px;
            background: #fff; border-radius: 10px; display: none; flex-direction: column;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3); z-index: 100; overflow: hidden;
            /* Ensure text is dark regardless of night mode */
            color: #333; 
        }
        #chat-modal.open { display: flex; }
        
        #chat-msgs { 
            flex: 1; padding: 10px; overflow-y: auto; 
            background: #f9f9f9; font-size: 0.9rem; color: #333; 
        }
        
        #chat-input-row { 
            display: flex; border-top: 1px solid #ddd; background: #fff; padding: 5px;
        }
        #chat-input-row input { 
            flex: 1; padding: 10px; border: 1px solid #ccc; outline: none; 
            border-radius: 5px; margin-left: 5px; background: #fff; color: #333;
        }
        #chat-input-row button { 
            padding: 0 15px; background: var(--accent); color: white; 
            border: none; border-radius: 5px; cursor: pointer;
        }
        
        #chat-btn {
            position: fixed; bottom: 20px; left: 20px; width: 50px; height: 50px;
            background: #00897b; border-radius: 50%; color: white;
            border: 2px solid white; cursor: pointer; box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            display: flex; justify-content: center; align-items: center;
        }
        #chat-badge {
            position: absolute; top: -5px; right: -5px; background: red; color: white;
            width: 20px; height: 20px; border-radius: 50%; font-size: 0.7rem;
            display: flex; justify-content: center; align-items: center; opacity: 0;
        }
        
        /* Winner Modal Specifics */
        #winner-modal {
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(5px);
            z-index: 2000;
        }
        #winner-modal h1 { font-size: 4rem; margin: 0; animation: pop 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        @keyframes pop { from { transform: scale(0); } to { transform: scale(1); } }
        
        @media (max-width: 600px) {
            #ui-bar { flex-direction: row-reverse; } /* Flip controls on mobile */
            #chat-modal { width: 90%; left: 5%; bottom: 90px; height: 40vh; }
            #room-badge { left: 50%; top: 10px; transform: translateX(-50%); font-size: 0.9rem; padding: 5px 12px; } /* Center room ID on mobile */
        }
    </style>
</head>
<body>

    <div id="loading-screen">
        <div class="loader"></div>
        <p style="margin-top:10px">ÿ¨ÿßÿ±Ÿä ÿ®ŸÜÿßÿ° ÿßŸÑŸÑŸàÿ≠ÿ©...</p>
    </div>

    <!-- Room ID Badge -->
    <div id="room-badge">ÿ∫ÿ±ŸÅÿ©: <span id="room-badge-id">---</span></div>

    <button id="night-btn">üåô</button>

    <!-- MENU SCREEN -->
    <div id="menu-screen" class="screen active">
        <div class="menu-box">
            <h2>üêç ÿßŸÑÿ≥ŸÑŸÖ ŸàÿßŸÑÿ´ÿπÿ®ÿßŸÜ</h2>
            <input type="text" id="p-name" placeholder="ÿßÿØÿÆŸÑ ÿßÿ≥ŸÖŸÉ ŸáŸÜÿß" maxlength="15">
            <p style="margin:10px 0 5px; font-size:0.9rem;">ÿßÿÆÿ™ÿ± ÿ¥ÿÆÿµŸäÿ™ŸÉ:</p>
            <div style="display:flex; gap:10px; justify-content:center; margin:10px 0;">
                <img src="https://api.dicebear.com/9.x/adventurer/svg?seed=Felix" class="avatar-opt" data-i="0" style="width:50px; height:50px; border-radius:50%; border:3px solid transparent; cursor:pointer; background:#eee;">
                <img src="https://api.dicebear.com/9.x/adventurer/svg?seed=Aneka" class="avatar-opt" data-i="1" style="width:50px; height:50px; border-radius:50%; border:3px solid transparent; cursor:pointer; background:#eee;">
                <img src="https://api.dicebear.com/9.x/adventurer/svg?seed=Zoe" class="avatar-opt" data-i="2" style="width:50px; height:50px; border-radius:50%; border:3px solid transparent; cursor:pointer; background:#eee;">
            </div>
            <input type="text" id="room-id" placeholder="ÿßŸÉÿ™ÿ® ÿ±ŸÇŸÖ ÿßŸÑÿ∫ÿ±ŸÅÿ© (ŸÑŸÑÿ•ŸÜÿ¥ÿßÿ° ÿ£Ÿà ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ)">
            <button id="btn-create">ÿ•ŸÜÿ¥ÿßÿ° ÿ∫ÿ±ŸÅÿ© (ÿ¨ÿØŸäÿØÿ©)</button>
            <button id="btn-join" style="background:#555">ÿßŸÜÿ∂ŸÖÿßŸÖ ŸÑÿ∫ÿ±ŸÅÿ© (ŸÖŸàÿ¨ŸàÿØÿ©)</button>
        </div>
    </div>

    <!-- GAME SCREEN -->
    <div id="game-screen" class="screen">
        <div id="game-area">
            <!-- Grid will be generated here -->
            <svg id="connections-layer" viewBox="0 0 100 100" preserveAspectRatio="none">
                <!-- Lines for Snakes and Ladders -->
            </svg>
        </div>

        <div id="ui-bar">
            <div id="dice-box">
                <div id="dice">
                    <div class="face front">1</div>
                    <div class="face back">6</div>
                    <div class="face right">3</div>
                    <div class="face left">4</div>
                    <div class="face top">2</div>
                    <div class="face bottom">5</div>
                </div>
            </div>
            <div id="status-txt">ÿßŸÜÿ™ÿ∏ÿ±...</div>
            <button id="roll-btn" disabled>ÿßÿ±ŸÖŸä</button>
        </div>

        <button id="chat-btn">
            <svg style="width:24px;height:24px;fill:white" viewBox="0 0 24 24"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2z"/></svg>
            <div id="chat-badge">0</div>
        </button>
        
        <div id="chat-modal">
            <div style="padding:10px; background:#f0f0f0; display:flex; justify-content:space-between; border-bottom:1px solid #ddd; color:#333;">
                <b>ÿßŸÑÿØÿ±ÿØÿ¥ÿ©</b>
                <span id="close-chat" style="cursor:pointer">‚úï</span>
            </div>
            <div id="chat-msgs"></div>
            <div id="chat-input-row">
                <input id="msg-in" type="text" placeholder="ÿßŸÉÿ™ÿ® ŸáŸÜÿß...">
                <button id="msg-send">‚û§</button>
            </div>
        </div>
    </div>

    <!-- WINNER MODAL -->
    <div id="winner-modal" class="screen">
        <div class="menu-box">
            <h1>üèÜ</h1>
            <h2 id="winner-name" style="color:#e65100; margin:10px 0;">ÿßÿ≥ŸÖ ÿßŸÑŸÅÿßÿ¶ÿ≤</h2>
            <p style="color:#555;">ŸÖÿ®ÿ±ŸàŸÉ! ŸÑŸÇÿØ ŸàÿµŸÑÿ™ ŸÑŸÑŸÇŸÖÿ©.</p>
            <button id="btn-replay" style="background:#43a047; font-size:1.1rem;">ŸÑÿπÿ® ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ üîÑ</button>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-app.js";
        import { getFirestore, collection, doc, setDoc, getDoc, onSnapshot, updateDoc, arrayUnion } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-firestore.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-auth.js";

        // --- GAME CONSTANTS ---
        const LADDERS = { 
            4: 14, 9: 31, 20: 38, 28: 84, 40: 59, 51: 67, 63: 81, 71: 91 
        };
        const SNAKES = { 
            17: 7, 54: 34, 62: 19, 64: 60, 87: 24, 93: 73, 95: 75, 99: 78 
        };

        const AVATARS = [
            'https://api.dicebear.com/9.x/adventurer/svg?seed=Felix',
            'https://api.dicebear.com/9.x/adventurer/svg?seed=Aneka',
            'https://api.dicebear.com/9.x/adventurer/svg?seed=Zoe'
        ];

        // Embedded Base64 Images
        const IMG_LADDER_B64 = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxMDAiPjxwYXRoIGQ9Ik0yLDAgVjEwMCBNMTgsMCBWMTAwIE0yLDEwIEgxOCBNMiwzMCBIMTggTTIsNTAgSDE4IE0yLDcwIEgxOCBNMiw5MCBIMTgiIHN0cm9rZT0iIzhCNDUxMyIgc3Ryb2tlLXdpZHRoPSIzIiBmaWxsPSJub25lIi8+PC9zdmc+";
        const IMG_SNAKE_B64 = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMCAxMDAiPjxwYXRoIGQ9Ik0xNSwwIEMzMCwyMCAwLDUwIDE1LDc1IFQxNSwxMDAiIHN0cm9rZT0iIzJGOCIgc3Ryb2tlLXdpZHRoPSI4IiBmaWxsPSJub25lIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48Y2lyY2xlIGN4PSIxNSIgY3k9IjUiIHI9IjMiIGZpbGw9InJlZCIvPjwvc3ZnPg==";

        // --- LOGIC ---
        function getCenter(num) {
            if (num < 1) num = 1; 
            if (num > 100) num = 100;
            const n = num - 1;
            const row = Math.floor(n / 10);
            const col = n % 10;
            let x, y;
            if (row % 2 === 0) x = col * 10 + 5;
            else x = (9 - col) * 10 + 5;
            y = (9 - row) * 10 + 5;
            return { x, y };
        }

        class Game {
            constructor() {
                this.tokens = {}; 
                // Initialize dice rotation tracking
                this.diceX = 0;
                this.diceY = 0;
                
                this.initFirebase();
                this.initBoard();
                this.setupUI();
                this.soundCtx = null;
            }

            initFirebase() {
                let config;
                
                // 1. ŸÖÿ≠ÿßŸàŸÑÿ© ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑŸÉŸàŸÜŸÅŸäÿ¨ ŸÖŸÜ ÿßŸÑÿ®Ÿäÿ¶ÿ© (Preview)
                if (typeof __firebase_config !== 'undefined') {
                    config = JSON.parse(__firebase_config);
                } else {
                    // 2. ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿÆÿßÿµÿ© (ŸÑÿ∂ŸÖÿßŸÜ ÿßŸÑÿπŸÖŸÑ ÿπŸÑŸâ ÿßŸÑÿßÿ≥ÿ™ÿ∂ÿßŸÅÿ©)
                    config = { 
                        apiKey: "AIzaSyD6MRZ7d7J1333erYoBrUGqocJNdGNjB7w", 
                        authDomain: "neew-aec2b.firebaseapp.com", 
                        databaseURL: "https://neew-aec2b-default-rtdb.firebaseio.com",
                        projectId: "neew-aec2b", 
                        storageBucket: "neew-aec2b.firebasestorage.app", 
                        messagingSenderId: "70112873200", 
                        appId: "1:70112873200:web:b8ef2b3863be6f1bf39035" 
                    };
                }

                try {
                    this.app = initializeApp(config);
                    this.db = getFirestore(this.app);
                    this.auth = getAuth(this.app);
                    
                    if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                        signInWithCustomToken(this.auth, __initial_auth_token);
                    } else {
                        signInAnonymously(this.auth);
                    }
                    
                    onAuthStateChanged(this.auth, u => {
                        this.user = u;
                        document.getElementById('loading-screen').style.display = 'none';
                    });
                } catch (e) {
                    alert("ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ŸÄ Firebase:\n" + e.message);
                }
            }

            setupUI() {
                document.querySelectorAll('.avatar-opt').forEach((img, i) => {
                    img.onclick = () => {
                        document.querySelectorAll('.avatar-opt').forEach(x => x.style.borderColor='transparent');
                        img.style.borderColor = '#ff9800';
                        this.selectedAvatar = i;
                    };
                });
                // Default avatar selection visually
                if(document.querySelector('.avatar-opt')) {
                    document.querySelector('.avatar-opt').style.borderColor = '#ff9800';
                }
                this.selectedAvatar = 0;

                document.getElementById('btn-create').onclick = () => this.createGame();
                document.getElementById('btn-join').onclick = () => this.joinGame();
                document.getElementById('roll-btn').onclick = () => this.handleRoll();
                document.getElementById('dice-box').onclick = () => {
                    if(!document.getElementById('roll-btn').disabled) this.handleRoll();
                };

                document.getElementById('chat-btn').onclick = () => {
                    document.getElementById('chat-modal').classList.toggle('open');
                    document.getElementById('chat-badge').style.opacity = 0;
                };
                document.getElementById('close-chat').onclick = () => document.getElementById('chat-modal').classList.remove('open');
                document.getElementById('msg-send').onclick = () => this.sendMsg();

                document.getElementById('night-btn').onclick = () => {
                    document.body.classList.toggle('night-mode');
                    this.playSound('click');
                };

                // Replay Button Logic
                document.getElementById('btn-replay').onclick = () => this.resetGame();

                document.addEventListener('click', () => this.initSound(), { once: true });
            }

            initBoard() {
                const board = document.getElementById('game-area');
                const svg = document.getElementById('connections-layer');
                
                for (let r = 9; r >= 0; r--) {
                    for (let c = 0; c < 10; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        let num;
                        if (r % 2 === 0) num = r * 10 + c + 1;
                        else num = r * 10 + (9 - c) + 1;
                        cell.style.bottom = `${r * 10}%`;
                        cell.style.left = `${c * 10}%`;
                        cell.textContent = num;
                        board.appendChild(cell);
                    }
                }

                // Updated drawLink using Embedded Images
                const drawLink = (start, end, imgUrl, type) => {
                    const s = getCenter(start);
                    const e = getCenter(end);
                    
                    const dx = e.x - s.x;
                    const dy = e.y - s.y;
                    const length = Math.sqrt(dx*dx + dy*dy);
                    const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                    
                    const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
                    
                    // Main Image
                    const img = document.createElementNS("http://www.w3.org/2000/svg", "image");
                    img.setAttributeNS('http://www.w3.org/1999/xlink', 'href', imgUrl);
                    
                    const cx = (s.x + e.x) / 2;
                    const cy = (s.y + e.y) / 2;
                    const width = (type === 'ladder') ? 6 : 6; 
                    
                    img.setAttribute("width", width);
                    img.setAttribute("height", length);
                    img.setAttribute("x", -width/2);
                    img.setAttribute("y", -length/2);
                    img.setAttribute("preserveAspectRatio", "none"); 
                    
                    const rot = angle - 90;
                    g.setAttribute("transform", `translate(${cx}, ${cy}) rotate(${rot})`);
                    
                    // Add a transparent thick line for visual backup
                    const backupLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    backupLine.setAttribute("x1", 0); backupLine.setAttribute("y1", -length/2);
                    backupLine.setAttribute("x2", 0); backupLine.setAttribute("y2", length/2);
                    backupLine.setAttribute("stroke", type === 'ladder' ? "rgba(139,69,19,0.2)" : "rgba(0,255,0,0.2)");
                    backupLine.setAttribute("stroke-width", width);
                    g.appendChild(backupLine);

                    g.appendChild(img);
                    svg.appendChild(g);
                };

                for (let [s, e] of Object.entries(LADDERS)) drawLink(parseInt(s), e, IMG_LADDER_B64, 'ladder');
                for (let [s, e] of Object.entries(SNAKES)) drawLink(parseInt(s), e, IMG_SNAKE_B64, 'snake');
            }

            async createGame() {
                const name = document.getElementById('p-name').value.trim();
                if (!name) {
                    alert("ÿßŸÑÿ±ÿ¨ÿßÿ° ÿ•ÿØÿÆÿßŸÑ ÿßÿ≥ŸÖŸÉ ÿ£ŸàŸÑÿßŸã!");
                    return;
                }

                try {
                    let roomId;
                    // Check if user entered a custom Room ID
                    const customId = document.getElementById('room-id').value.trim();
                    
                    if (customId) {
                        roomId = customId;
                        // Check availability
                        const ref = doc(this.db, 'artifacts', this.appId(), 'public', 'data', 'rooms', roomId);
                        const snap = await getDoc(ref);
                        if (snap.exists()) {
                            alert("Ÿáÿ∞Ÿá ÿßŸÑÿ∫ÿ±ŸÅÿ© ŸÖŸàÿ¨ŸàÿØÿ© ÿ®ÿßŸÑŸÅÿπŸÑ! ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßÿÆÿ™Ÿäÿßÿ± ÿ±ŸÇŸÖ ÿ¢ÿÆÿ± ÿ£Ÿà ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ÿ•ŸÑŸäŸáÿß.");
                            return;
                        }
                    } else {
                        // Generate random ID
                        roomId = Math.floor(1000 + Math.random() * 9000).toString();
                    }

                    this.roomId = roomId;
                    this.myId = this.user.uid;
                    
                    const data = {
                        players: [{ id: this.myId, name, avatar: this.selectedAvatar, pos: 1 }],
                        turn: 0, lastRoll: 0, winner: null, chat: []
                    };
                    
                    await setDoc(doc(this.db, 'artifacts', this.appId(), 'public', 'data', 'rooms', roomId), data);
                    this.startListening();
                } catch (e) {
                    alert("ŸÅÿ¥ŸÑ ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ∫ÿ±ŸÅÿ©. ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ•ÿπÿØÿßÿØÿßÿ™ Firebase.\n\n" + e.message);
                }
            }

            async joinGame() {
                const name = document.getElementById('p-name').value.trim();
                if (!name) {
                    alert("ÿßŸÑÿ±ÿ¨ÿßÿ° ÿ•ÿØÿÆÿßŸÑ ÿßÿ≥ŸÖŸÉ ÿ£ŸàŸÑÿßŸã!");
                    return;
                }

                try {
                    const roomId = document.getElementById('room-id').value.trim();
                    if(!roomId) return alert("ÿ£ÿØÿÆŸÑ ÿ±ŸÇŸÖ ÿßŸÑÿ∫ÿ±ŸÅÿ©");
                    this.roomId = roomId;
                    this.myId = this.user.uid;

                    const ref = doc(this.db, 'artifacts', this.appId(), 'public', 'data', 'rooms', roomId);
                    const snap = await getDoc(ref);
                    
                    if(snap.exists()) {
                        const data = snap.data();
                        if(!data.players.find(p => p.id === this.myId)) {
                            data.players.push({ id: this.myId, name, avatar: this.selectedAvatar, pos: 1 });
                            await updateDoc(ref, { players: data.players });
                        }
                        this.startListening();
                    } else {
                        alert("ÿ∫ÿ±ŸÅÿ© ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØÿ©");
                    }
                } catch(e) {
                    alert("ŸÅÿ¥ŸÑ ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ. ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ•ÿπÿØÿßÿØÿßÿ™ Firebase.\n\n" + e.message);
                }
            }

            startListening() {
                document.getElementById('menu-screen').classList.remove('active');
                document.getElementById('game-screen').classList.add('active');
                
                // Show Room ID on screen
                document.getElementById('status-txt').innerText = "ÿßŸÜÿ™ÿ∏ÿ±...";
                document.getElementById('room-badge').classList.add('visible');
                document.getElementById('room-badge-id').innerText = this.roomId;

                onSnapshot(doc(this.db, 'artifacts', this.appId(), 'public', 'data', 'rooms', this.roomId), snap => {
                    if(snap.exists()) this.updateState(snap.data());
                });
            }

            // --- REPLAY LOGIC ---
            async resetGame() {
                // Reset game state in Firestore so all players see the reset
                if (!this.state) return;
                
                // Keep players but reset positions
                const resetPlayers = this.state.players.map(p => ({ ...p, pos: 1 }));
                
                await updateDoc(doc(this.db, 'artifacts', this.appId(), 'public', 'data', 'rooms', this.roomId), {
                    players: resetPlayers,
                    turn: 0,
                    lastRoll: 0,
                    winner: null
                });
                
                this.playSound('click');
            }

            // --- CORE MOVEMENT LOGIC ---
            async updateState(data) {
                this.state = data;
                
                // Check Winner & Show/Hide Modal
                if (data.winner) {
                    document.getElementById('winner-name').innerText = data.winner.name;
                    document.getElementById('winner-modal').classList.add('active');
                    if(this.lastWinner !== data.winner.id) {
                        this.playSound('win');
                        this.lastWinner = data.winner.id;
                    }
                } else {
                    // If no winner (e.g. game reset), hide modal
                    document.getElementById('winner-modal').classList.remove('active');
                    this.lastWinner = null;
                }

                // Process players
                for (const p of data.players) {
                    const pIdx = data.players.indexOf(p);
                    
                    // Create token if not exists
                    if (!this.tokens[p.id]) {
                        const token = document.createElement('div');
                        token.className = 'player-token';
                        token.style.backgroundImage = `url(${AVATARS[p.avatar]})`;
                        const colors = ['#f44336', '#2196f3', '#4caf50', '#ff9800'];
                        token.style.borderColor = colors[pIdx % 4];
                        
                        // Initial Position
                        const pos = getCenter(p.pos);
                        token.style.left = pos.x + '%';
                        token.style.top = pos.y + '%';
                        
                        document.getElementById('game-area').appendChild(token);
                        this.tokens[p.id] = { el: token, currentPos: p.pos };
                    } 
                    else {
                        const tokenObj = this.tokens[p.id];
                        const targetPos = p.pos;
                        
                        // Check if movement needed
                        if (tokenObj.currentPos !== targetPos) {
                            
                            let start = tokenObj.currentPos;
                            let intermediate = targetPos;
                            let isJump = false;

                            if (data.lastRoll && Math.abs(targetPos - start) > data.lastRoll) {
                                const hypotheticalLand = start + data.lastRoll;
                                if (LADDERS[hypotheticalLand] === targetPos || SNAKES[hypotheticalLand] === targetPos) {
                                    intermediate = hypotheticalLand;
                                    isJump = true;
                                }
                            }

                            // If reset happened (target = 1, current > 1), just snap or move fast back
                            if (targetPos === 1 && start > 1 && !data.winner) {
                                // Game reset
                                await this.moveTokenVisual(tokenObj.el, 1, true);
                                tokenObj.currentPos = 1;
                                continue;
                            }

                            // Phase 1: Walk to intermediate (Step by Step)
                            if (intermediate > start) {
                                for (let i = start + 1; i <= intermediate; i++) {
                                    await this.moveTokenVisual(tokenObj.el, i);
                                    this.playSound('step');
                                }
                            } else if (intermediate < start && !isJump) {
                                await this.moveTokenVisual(tokenObj.el, intermediate);
                            }

                            // Phase 2: Handle Jump (Snake/Ladder)
                            if (isJump) {
                                await new Promise(r => setTimeout(r, 400)); 
                                if (targetPos > intermediate) this.playSound('ladder'); 
                                else this.playSound('snake'); 
                                
                                await this.moveTokenVisual(tokenObj.el, targetPos, true); 
                            }

                            tokenObj.currentPos = targetPos;
                        }
                    }
                }

                // Update UI Controls
                const isMyTurn = data.players[data.turn].id === this.myId;
                const btn = document.getElementById('roll-btn');
                const status = document.getElementById('status-txt');
                
                if (data.winner) {
                    status.innerHTML = `<span style="color:gold">ÿßŸÑŸÅÿßÿ¶ÿ≤: ${data.winner.name}</span>`;
                    btn.disabled = true;
                } else {
                    const currentName = data.players[data.turn].name;
                    status.innerText = isMyTurn ? `ÿØŸàÿ±ŸÉ ÿßŸÑÿ¢ŸÜ! (ÿ∫ÿ±ŸÅÿ© ${this.roomId})` : `ÿØŸàÿ± ${currentName}`;
                    btn.disabled = !isMyTurn;
                    if(isMyTurn) btn.style.background = getComputedStyle(document.body).getPropertyValue('--accent');
                    else btn.style.background = '#777';
                }

                // Update Chat
                const chatBox = document.getElementById('chat-msgs');
                if (data.chat.length !== chatBox.children.length) {
                    chatBox.innerHTML = '';
                    data.chat.forEach(msg => {
                        const div = document.createElement('div');
                        div.style.marginBottom = '5px';
                        div.innerHTML = `<b>${msg.name}:</b> ${msg.text}`;
                        chatBox.appendChild(div);
                    });
                    chatBox.scrollTop = chatBox.scrollHeight;
                }
            }

            // Helper to move token visually
            moveTokenVisual(el, num, isJump = false) {
                return new Promise(resolve => {
                    const pos = getCenter(num);
                    el.style.left = pos.x + '%';
                    el.style.top = pos.y + '%';
                    
                    // Wait for CSS transition to finish
                    setTimeout(resolve, isJump ? 600 : 300); 
                });
            }

            async handleRoll() {
                document.getElementById('roll-btn').disabled = true;
                this.playSound('dice');
                
                // Add Jump Effect class
                document.getElementById('dice-box').classList.add('jumping');
                
                const dice = document.getElementById('dice');
                const roll = Math.floor(Math.random() * 6) + 1;
                
                const rot = { 1: [0, 0], 2: [-90, 0], 3: [0, -90], 4: [0, 90], 5: [90, 0], 6: [180, 0] };
                const x = rot[roll][0] + 720;
                const y = rot[roll][1] + 720;
                
                const currentModX = this.diceX % 360;
                const currentModY = this.diceY % 360;
                
                let diffX = rot[roll][0] - currentModX;
                let diffY = rot[roll][1] - currentModY;
                
                if (diffX <= 0) diffX += 360;
                if (diffY <= 0) diffY += 360;
                
                this.diceX += diffX + 720; 
                this.diceY += diffY + 720;
                
                dice.style.transform = `rotateX(${this.diceX}deg) rotateY(${this.diceY}deg)`;
                
                await new Promise(r => setTimeout(r, 1000));
                document.getElementById('dice-box').classList.remove('jumping');
                
                const pIdx = this.state.turn;
                const p = this.state.players[pIdx];
                let nextPos = p.pos + roll;
                if(nextPos > 100) nextPos = p.pos;
                
                let finalPos = nextPos;
                if(LADDERS[nextPos]) finalPos = LADDERS[nextPos];
                else if(SNAKES[nextPos]) finalPos = SNAKES[nextPos];

                const players = [...this.state.players];
                players[pIdx].pos = finalPos;
                
                let winner = null;
                if(finalPos === 100) winner = players[pIdx];
                
                const nextTurn = (pIdx + 1) % players.length;
                
                await updateDoc(doc(this.db, 'artifacts', this.appId(), 'public', 'data', 'rooms', this.roomId), {
                    players, turn: nextTurn, lastRoll: roll, winner
                });
            }

            async sendMsg() {
                const inp = document.getElementById('msg-in');
                const text = inp.value;
                if(!text) return;
                
                const myName = this.state.players.find(p => p.id === this.myId).name;
                await updateDoc(doc(this.db, 'artifacts', this.appId(), 'public', 'data', 'rooms', this.roomId), {
                    chat: arrayUnion({ name: myName, text })
                });
                inp.value = '';
                this.playSound('click');
            }

            initSound() {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.soundCtx = new AudioContext();
            }

            playSound(type) {
                if(!this.soundCtx) return;
                const osc = this.soundCtx.createOscillator();
                const gain = this.soundCtx.createGain();
                osc.connect(gain);
                gain.connect(this.soundCtx.destination);
                
                const now = this.soundCtx.currentTime;
                
                if(type === 'dice') {
                    [0, 0.15, 0.3, 0.45, 0.6].forEach(t => {
                        const o = this.soundCtx.createOscillator();
                        const g = this.soundCtx.createGain();
                        o.connect(g); g.connect(this.soundCtx.destination);
                        o.type = 'triangle';
                        o.frequency.value = 100 + Math.random()*50;
                        g.gain.setValueAtTime(0, now + t);
                        g.gain.linearRampToValueAtTime(0.1, now + t + 0.05);
                        g.gain.exponentialRampToValueAtTime(0.01, now + t + 0.15);
                        o.start(now + t); o.stop(now + t + 0.15);
                    });
                }
                else if(type === 'step') {
                    osc.type = 'sine'; osc.frequency.setValueAtTime(400, now);
                    gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    osc.start(now); osc.stop(now + 0.1);
                }
                else if(type === 'ladder') {
                    osc.type = 'sine'; osc.frequency.setValueAtTime(300, now);
                    osc.frequency.linearRampToValueAtTime(600, now + 0.3);
                    gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now + 0.3);
                    osc.start(now); osc.stop(now + 0.3);
                }
                else if(type === 'snake') {
                    osc.type = 'sawtooth'; osc.frequency.setValueAtTime(400, now);
                    osc.frequency.linearRampToValueAtTime(100, now + 0.4);
                    gain.gain.setValueAtTime(0.05, now); gain.gain.linearRampToValueAtTime(0, now + 0.4);
                    osc.start(now); osc.stop(now + 0.4);
                }
                else if(type === 'win') {
                    osc.type = 'triangle'; osc.frequency.setValueAtTime(523, now);
                    gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 1);
                    osc.start(now); osc.stop(now + 1);
                }
                else {
                    osc.type = 'sine'; osc.frequency.setValueAtTime(800, now);
                    gain.gain.setValueAtTime(0.05, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
                    osc.start(now); osc.stop(now + 0.05);
                }
            }

            appId() { return typeof __app_id !== 'undefined' ? __app_id : 'default'; }
        }

        window.onload = () => new Game();
    </script>
</body>
</html>
